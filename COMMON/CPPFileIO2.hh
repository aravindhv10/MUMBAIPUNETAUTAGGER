#ifndef CPPFileIO_HH
#define CPPFileIO_HH
/////////////////////////
#include <stdio.h> //////
#include <time.h>   /////
#include <stdlib.h> /////
#include <string.h> /////
#include <sys/types.h> //
#include <sys/wait.h> ///
#include <sys/stat.h> ///
#include <sys/mman.h> ///
#include <fcntl.h> //////
#include <unistd.h> /////
#include <math.h> ///////
#include <string.h> /////
/////////////////////////
#include <iostream> /////
#include <vector> ///////
#include <algorithm> ////
#include <random> ///////
#include <sstream> //////
#include <iomanip> //////
#include <utility> //////
#include <fstream> //////
#include <exception> ////
/////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace CPPFileIO { //////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pointer Management: /////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    const char junk_address = '0' ; ////////////////////////////////////////////////////////////////////////////////////////////////
    const bool DEBUG = false; //////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline void set_junked  ( T * & inptr ) { inptr=(T*)(&junk_address);} ////////////////////////////////////
    template <typename T> inline bool is_junked   ( T * & inptr ) { return (inptr==(T*)(&junk_address));} //////////////////////////
    template <typename T> inline bool safe_delete ( T * & inptr ) { ////////////////////////////////////////////////////////////////
        if (!is_junked(inptr)) { delete inptr; set_junked(inptr); return true; } else {return false;} //////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline bool safe_delete_array ( T * & inptr ) { //////////////////////////////////////////////////////////
        if (!is_junked(inptr)) { delete[] inptr; set_junked(inptr); return true; } else {return false;} ////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    inline size_t shifter  (size_t in) {return (1<<in);} ///////////////////////////////////////////////////////////////////////////
    inline bool   checkbit (size_t inbits, size_t checkbits) {return ((inbits&checkbits)==checkbits);} /////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    size_t NTHREADS = 4 ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Useful template functions : /////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T    mymod  ( T   a         ) { if (a<0) { return -a ; } else { return a ; } } ////////////////////
    template <typename T> inline T    mymax  ( T   a , T   b ) { if (a<b) { return  b ; } else { return a ; } } ////////////////////
    template <typename T> inline T    mymin  ( T   a , T   b ) { if (a<b) { return  a ; } else { return b ; } } ////////////////////
    template <typename T> inline T    mysign ( T   a         ) { if (a<0) { return -1 ; } else { return 1 ; } } ////////////////////
    template <typename T> inline void myswap ( T & a , T & b ) { T tmp = b ; b = a ; a = tmp ;                } ////////////////////
    template <typename T> inline long myint  ( T   x         ) { return (long) x ;                            } ////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some simple and essential mathematics functions: ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T GCD (T a, T b) { ////////////////////////////////////////////////////////////////////////////////
        T ret ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        while( (a!=0) && (b!=0) ) { ////////////////////////////////////////////////////////////////////////////////////////////////
            if (a>b) { a = a % b ; ret = b ; } /////////////////////////////////////////////////////////////////////////////////////
            else     { b = b % a ; ret = a ; } /////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        return ret; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T LCM (T a, T b) { ////////////////////////////////////////////////////////////////////////////////
        T ret ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ret = GCD(a,b); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (ret>0) { ret = a * ( b / ret ) ; } /////////////////////////////////////////////////////////////////////////////////////
        return ret; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some useful OS related functions : //////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void starter_self ( std::vector <std::string> & program ) { ////////////////////////////////////////////////////////////////////
        std::vector <char*> arrs ; /////////////////////////////////////////////////////////////////////////////////////////////////
        int j = program.size() ; ///////////////////////////////////////////////////////////////////////////////////////////////////
        arrs.resize(j+1); //////////////////////////////////////////////////////////////////////////////////////////////////////////
        for(int i=0;i<j;i++) { arrs[i] = & (program[i][0]) ; } /////////////////////////////////////////////////////////////////////
        arrs[j] = (char*) NULL ; ///////////////////////////////////////////////////////////////////////////////////////////////////
        execvp ( (const char *) arrs[0] , & (arrs[0]) ) ; //////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    pid_t starter_fork ( std::vector <std::string> & program ) { ///////////////////////////////////////////////////////////////////
        pid_t tmp_pid = fork(); ////////////////////////////////////////////////////////////////////////////////////////////////////
        if (tmp_pid==0) { starter_self (program) ; } ///////////////////////////////////////////////////////////////////////////////
        else { return tmp_pid ; } //////////////////////////////////////////////////////////////////////////////////////////////////
        return tmp_pid ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void waitonall (std::vector <pid_t> childs) { //////////////////////////////////////////////////////////////////////////////////
        for(int i=0;i<childs.size();i++) { pid_t tmp = waitpid ( (pid_t) childs[i] , (int *) NULL , (int) 0 ) ; } //////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class GetArgs { ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> args ; ///////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        GetArgs  (int _argc, char ** _argv) {for(size_t i=0;i<_argc;i++){args.push_back(_argv[i]);}} ///////////////////////////////
        ~GetArgs ()                         {} /////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) { return args[i]      ; } //////////////////////////////////////////////////////
        inline size_t        operator () ()         { return args.size () ; } //////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Nice Class to handel forking: ///////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class ForkMe { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        private: ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            std::vector <pid_t> kids  ; ////////////////////////////////////////////////////////////////////////////////////////////
            bool                child ; ////////////////////////////////////////////////////////////////////////////////////////////
            size_t              kid_count ; ////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        public: ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline bool WaitOnKids () { ////////////////////////////////////////////////////////////////////////////////////////////
                if      ( child           ) { exit (0)         ; return false ;               } ////////////////////////////////////
                else if ( kids.size() > 0 ) { waitonall (kids) ; kids.clear() ; return true ; } ////////////////////////////////////
                else                        { return false     ;                              } ////////////////////////////////////
                kid_count = 1 ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ForkMe  () { kids.clear () ; child = false ; kid_count = 1 ; } /////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ~ForkMe () { if (child) { exit (0) ; } else { WaitOnKids () ; } } //////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline bool InKid () { /////////////////////////////////////////////////////////////////////////////////////////////////
                if (!child){ ///////////////////////////////////////////////////////////////////////////////////////////////////////
                    pid_t tmp_pid = fork () ; //////////////////////////////////////////////////////////////////////////////////////
                    if (tmp_pid==0) { child = true             ; return true  ; } //////////////////////////////////////////////////
                    else            { kids.push_back (tmp_pid) ; kid_count++ ; return false ; } ////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { exit (0) ; return false ; } /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline void operator () (size_t _count=1) { ////////////////////////////////////////////////////////////////////////////
                if(kid_count>_count) { WaitOnKids () ; } ///////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class starter { ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The main elements: //////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ForkMe forks ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Constructor and Destructor: /////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        starter  () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~starter () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The main functions: /////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void series (std::vector <std::string> & program) { ////////////////////////////////////////////////////////////////////////
            ForkMe tmp ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(tmp.InKid()) {starter_self(program);} ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void parallel (std::vector <std::string> & program) { //////////////////////////////////////////////////////////////////////
            if(forks.InKid()) {starter_self(program);} /////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void wait () {forks.WaitOnKids();} /////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some functions to simplify handling vectors: ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void clone_vector ( const std::vector <T> & src , std::vector <T> & dest ) { /////////////////////////////
        size_t n = src.size() ; ////////////////////////////////////////////////////////////////////////////////////////////////////
        dest.resize(n); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (void *) memcpy ( (void *) &(dest[0]), (const void *) &(src[0]), (size_t) n*sizeof(T) ); ///////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void deduplicate (std::vector <T> & array) { /////////////////////////////////////////////////////////////
        std::vector <T> tmp_array ; ////////////////////////////////////////////////////////////////////////////////////////////////
        size_t SZ = array.size(); //////////////////////////////////////////////////////////////////////////////////////////////////
        if(SZ>1) { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            std::sort(array.begin(),array.end()); tmp_array.push_back(array[0]); ///////////////////////////////////////////////////
            for(size_t i=1;i<SZ;i++) if(array[i]!=array[i-1]) {tmp_array.push_back(array[i]);} /////////////////////////////////////
            array.resize(tmp_array.size()) ; ///////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void *) &(array[0]) , (const void *) &(tmp_array[0]) , sizeof(T) * tmp_array.size() ) ; //////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Function to read a file line by line: ///////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void getnames ( std::vector <std::string> & lines , std::string filename ) { ///////////////////////////////////////////////////
        lines.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char *line=NULL; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t len=0; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ssize_t read; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FILE *stream = fopen (&(filename[0]),"r") ; ////////////////////////////////////////////////////////////////////////////////
        while ((read = getline(&line, &len, stream)) != -1) { //////////////////////////////////////////////////////////////////////
            std::string linename(line); ////////////////////////////////////////////////////////////////////////////////////////////
            linename[linename.size()-1]=0; /////////////////////////////////////////////////////////////////////////////////////////
            lines.push_back(linename); /////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (len>0) {free(line);} ///////////////////////////////////////////////////////////////////////////////////////////////////
        fclose(stream); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileLines { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> lines    ; ///////////////////////////////////////////////////////////////////////////////////////
        std::string               filename ; ///////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileLines  (std::string _filename) : filename(_filename) {getnames(lines,filename);} ///////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~FileLines () {} ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) { return lines[i]      ; } /////////////////////////////////////////////////////
        inline size_t        size        ()         { return lines.size () ; } /////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) { return lines[i]      ; } /////////////////////////////////////////////////////
        inline size_t        operator () ()         { return lines.size () ; } /////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (FILE *f) { for (size_t i=0;i<lines.size();i++) {fprintf(f,"%s\n",&(lines[i][0]));} } //////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<lines.size();i++) {printf("%ld => [%s]\n",i,&(lines[i][0]));} } /////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class StringSplit { ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The Main Data Elements: /////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::string               line    ; ////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> words   ; ////////////////////////////////////////////////////////////////////////////////////////
        char                      delimit ; ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Important functions: ////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        StringSplit  ( std::string _line = "" , char _delimit = ' ' ) : line(_line) , delimit(_delimit) { //////////////////////////
            std::vector <char> buf ; buf.reserve(line.size()) ; ////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<line.size();i++) { ///////////////////////////////////////////////////////////////////////////////////
                if (line[i]==delimit) { ////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back(line[i]); ////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { buf.push_back(line[i]); } ///////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (buf.size()>0) { ////////////////////////////////////////////////////////////////////////////////////////////////////
                buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
                words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////////
                buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~StringSplit () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Some convinent functions: ///////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        size        ()         {return words.size() ; } ///////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        operator () ()         {return words.size() ; } ///////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Print the string: ///////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void show (std::string & in_line) { ////////////////////////////////////////////////////////////////////////////////////////
            std::vector <char> outline ; ///////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<words.size();i++) for(size_t j=0;j<words[i].size();j++) if(words[i][j]!=(char)0) {outline.push_back(words[i][j]);}
            outline.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
            in_line = std::string( &(outline[0]) ); ////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (std::string & in_line) {show(in_line);} ///////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<words.size();i++) {printf("(%ld:%s)",i,&(words[i][0]));} } //////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // The Main and most important class for simplifying file handeling: ///////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileFD { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        std::string  filename  ;
        int          fd        ;
        struct stat  abtme     ;
        int          filemode  ;
        void        *mapped    ;
        size_t       maplength ;
        int          mmapprot  ;

    public:
        void construct ( std::string Afile = std::string("outfile") ) {
            filename  = Afile      ;
            fd        = -1         ;
            filemode  = -1         ;
            mapped    = MAP_FAILED ;
            mmapprot  = PROT_NONE  ;
            maplength = 0          ;
        }
        int closefile () {
            unmapfile()          ;
            filemode = -1        ;
            mmapprot = PROT_NONE ;
            if (fd<0) {return 0;}
            else {
                int ret = (int) close ( (int) fd ) ;
                fd = -1 ;
                return ret ;
            }
        }
        inline void check_file_mode (int newfilemode = -1) {
            if (filemode!=newfilemode) {closefile();}
            if (fd<0) {
                fd = (int) open ( (const char *) &(filename[0]) , newfilemode , (mode_t) 0755 ) ;
                filemode = newfilemode ;
            }
        }
        inline void readfile   () { check_file_mode ( (int) O_RDONLY                     ) ; mmapprot = ( (int) PROT_READ               ) ; }
        inline void writefile  () { check_file_mode ( (int) O_WRONLY | O_CREAT | O_TRUNC ) ; mmapprot = ( (int) PROT_WRITE              ) ; }
        inline void appendfile () { check_file_mode ( (int) O_RDWR   | O_CREAT           ) ; mmapprot = ( (int) PROT_READ  | PROT_WRITE ) ; }
        inline void destroy    () { closefile       (                                    ) ;                                                }

        FileFD  ( const char *Afile ) { construct ( Afile ) ; }
        FileFD  (                   ) { construct (       ) ; }
        FileFD  ( std::string Afile ) { construct ( Afile ) ; }
        ~FileFD (                   ) { destroy   (       ) ; }

        void reconstruct (std::string Afile = std::string("outfile")) { destroy() ; construct (Afile) ; }
        void reconstruct (char *Afile) { reconstruct (std::string(Afile)) ; }
        inline FileFD & operator () ( std::string name ) { reconstruct(name) ; return (*this); }

        inline int truncatefile ( off_t length = 0 ) { return (int) ftruncate ( (int) fd , (off_t) length ) ; }
        inline off_t seekfile ( off_t offset = 0 , int whence = SEEK_CUR ) { return (off_t) lseek ( (int) fd , (off_t) offset , (int) whence ) ; }
        inline ssize_t read2file ( void *buf = NULL , size_t count = 0 ) { return (ssize_t) read ( (int) fd , ( void *) buf , (size_t) count ) ; }
        inline ssize_t write2file ( const void *buf = NULL , size_t count = 0 ) { return (ssize_t) write ( (int) fd , (const void *) buf , (size_t) count ) ; }
        inline int info () { return (int) fstat ( (int) fd , (struct stat *) &abtme ) ; }
        inline off_t sizefile () { info() ; return (off_t) abtme.st_size ; }
        inline std::string getfilename () { return filename; }
        inline off_t operator () ( off_t offset = 0 ) { return seekfile ( offset ) ; }
        inline FileFD & operator [] ( off_t pos ) { seekfile ( (off_t) pos , SEEK_SET ) ; return (*this) ; }
        inline int getfd () { return fd ; }

        void * mapfile ( size_t length, off_t offset = 0 ) {
            if( (maplength==0) && (mmapprot!=PROT_NONE) && (mapped==MAP_FAILED) ) {
                off_t total_len = length + offset ;
                if (sizefile()<total_len) {truncatefile(total_len);}
                mapped = (void *) mmap ( (void *) NULL , (size_t) length, (int) mmapprot , (int) MAP_SHARED , (int) fd , (off_t) offset );
                if (mapped!=MAP_FAILED) {maplength=length;}
                else {printf("MMAP FAILED 1 !!! %s\n",&(filename[0]));}
            }
            else {printf("MMAP FAILED 2 !!!\n");}
            return mapped;
        }

        int unmapfile () {
            int ret = 0 ;
            if ( (mapped!=MAP_FAILED) && (maplength>0) && (mmapprot!=PROT_NONE) ) {
                ret = (int) munmap ( (void *) mapped , (size_t) maplength ) ;
                maplength = 0 ;
                mapped = MAP_FAILED ;
            }
            return ret;
        }

        inline size_t getmaplength () { return maplength ; }

        template <typename T> inline ssize_t multiread2file  ( T &buf , size_t count = 1 ) { return read2file  ( (      void *) &buf , (size_t) sizeof(T) * count ) ; }
        template <typename T> inline ssize_t multiwrite2file ( T &buf , size_t count = 1 ) { return write2file ( (const void *) &buf , (size_t) sizeof(T) * count ) ; }

        template <typename T> inline ssize_t WriteVector ( std::vector <T> &out ) {
            size_t count = out.size() ;
            ssize_t writtensize = multiwrite2file (count) ;
            writtensize = writtensize + multiwrite2file (out[0],count) ;
            return writtensize;
        }

        template <typename T> inline ssize_t ReadVector ( std::vector <T> &out ) {
            size_t count = 0 ;
            size_t oldsize = out.size() ;
            ssize_t writtensize = multiread2file (count) ;
            out.resize ( oldsize + count ) ;
            writtensize = multiread2file ( out[oldsize], count ) ;
            return writtensize;
        }

        inline ssize_t WriteString ( std::string &out ) {
            size_t count       = out.size() ;
            ssize_t writtensize = multiwrite2file ( count ) ;
            writtensize = writtensize + multiwrite2file(out[0],count) ;
            return writtensize;
        }

        inline ssize_t operator >> ( char      & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( char        out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( int       & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( int         out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( float     & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( float       out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( double    & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( double      out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( long      & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( long        out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( size_t    & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( size_t      out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator << ( std::string out ) { return WriteString     ( out ) ; }

        template <typename T> inline ssize_t operator << ( std::vector <T> &out ) { return WriteVector(out); }
        template <typename T> inline ssize_t operator >> ( std::vector <T> &out ) { return ReadVector (out); }
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Simple function for TRUE random number generation: //////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    double unique () { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        struct timespec timeout ; //////////////////////////////////////////////////////////////////////////////////////////////////
        clock_gettime(CLOCK_REALTIME,&timeout); ////////////////////////////////////////////////////////////////////////////////////
        double ret = (double) ( timeout.tv_sec + ( (double) timeout.tv_nsec / 1000000000 ) ) ; /////////////////////////////////////
        FileFD urandom((char *)"/dev/urandom"); ////////////////////////////////////////////////////////////////////////////////////
        urandom.readfile(); ////////////////////////////////////////////////////////////////////////////////////////////////////////
        double rnd ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
        urandom >> rnd ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ret = ret * rnd ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
        return ret;  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void GetUnique (T & Var) { double ptr = unique() ; Var=*((T*)&ptr); } ////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class for simplifying memory mapping and array handeling: ///////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FileArray { ////////////////////////////////////////////////////////////////////////////////////////

    private:
        T *mainptr  ;
        size_t sizes[4] ;
        std::string filename ;
        FileFD filefd ;
        size_t offset ;
        size_t begin, end, length ;
        size_t act_begin, act_end, act_length ;

    public:
        inline void construct ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) {
            filename = Afilename ;
            filefd(filename).readfile() ;
            sizes[0] = 4096 ;
            sizes[1] = sizeof (T) ;
            sizes[2] = LCM (sizes[0],sizes[1]) ;
            sizes[3] = sizes[2] / sizes[1] ;
            offset = Aoffset ;
            begin = 0 ; act_begin = 0 ;
            end = 0 ; act_end = 0 ;
            length = 0 ; act_length = 0 ;
        }

        inline void destroy () { filefd.destroy () ; }
        inline void reconstruct ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) { destroy(); construct(Afilename,Aoffset); }
        inline FileArray & operator () ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) {
            reconstruct (Afilename,Aoffset) ;
            return (*this) ;
        }

        FileArray ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) { construct(Afilename,Aoffset); }
        ~FileArray () {destroy();}

        inline void writeable ( bool arg = true ) {
            if(arg) {filefd(filename).appendfile();}
            else {filefd(filename).readfile();}
        }

        void map (size_t t_begin=0, size_t t_length=1) {
            size_t t_end = t_begin + t_length ;
            if ((t_begin<begin)||(t_end>end)) {
                /* Match to sector sizes: */ {
                    begin = myint ((double)t_begin/sizes[3]) ; begin = begin * sizes[3] ;
                    length = myint ((double)t_length/sizes[3]) ; length++ ; length = length * sizes[3] ;
                    end = begin + length ;
                }
                /* Reinitiate map: */ {
                    filefd.unmapfile () ;
                    mainptr = (T*) filefd.mapfile ( (length*sizes[1]) , (begin*sizes[1]) + (offset*sizes[0]) ) ;
                }
            }
        }

        inline T & operator () ( size_t A_begin=0 , size_t A_length=1 ) {
            map (A_begin,A_length) ;
            return mainptr [A_begin-begin] ;
        }

        inline off_t filesize () { return filefd.sizefile () ; }
        inline off_t size () { return filefd.sizefile () / sizes[1] ; }
        inline off_t size ( long num ) { filefd.unmapfile(); filefd.truncatefile(num*sizes[1]); return size(); }
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FileVector { ///////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileArray <T> infile ; /////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t count ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileVector(std::string name): infile(name){ ////////////////////////////////////////////////////////////////////////////////
            infile.writeable(); ////////////////////////////////////////////////////////////////////////////////////////////////////
            count=0; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            infile.size(count); ////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~FileVector(){infile.size(count);} /////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t size() {return count ;} ////////////////////////////////////////////////////////////////////////////////
        inline void resize(size_t _size) {count=_size;} //////////////////////////////////////////////////////////////////////
        inline void push_back (T indata) { /////////////////////////////////////////////////////////////////////////////////////////
            infile(count) = indata ; ///////////////////////////////////////////////////////////////////////////////////////////////
            count++ ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return infile(i);} //////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    template < typename T > class latexshow { /////////////////////////
        ///////////////////////////////////////////////////////////////
    private:
        ///////////////////////////////////////////////////////////////
        long power; ///////////////////////////////////////////////////
        T num; ////////////////////////////////////////////////////////
        T input; //////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline void reduce () { ///////////////////////////////////////
            ///////////////////////////////////////////////////////////
            while ((-1<num) && (num<1) && (num!=0)) { /////////////////
                num = num * 10.0; /////////////////////////////////////
                power--; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
            while ((num > 10) || (-10 > num)) { ///////////////////////
                num = num / 10.0; /////////////////////////////////////
                power++; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * show (char * b) { ///////////////////////////////
            ///////////////////////////////////////////////////////////
            if ( mymod(power) > limit ) { /////////////////////////////
                sprintf (b, "{$%.3lf \\times 10^{%ld}$}", num, power);
            } else { //////////////////////////////////////////////////
                sprintf (b, "{$%.3lf$}", input); //////////////////////
            } /////////////////////////////////////////////////////////
            return b ; ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
    public:
        ///////////////////////////////////////////////////////////////
        size_t limit; /////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        latexshow (T a) { /////////////////////////////////////////////
            ///////////////////////////////////////////////////////////
            input = a; ////////////////////////////////////////////////
            num = a; //////////////////////////////////////////////////
            power = 0; ////////////////////////////////////////////////
            limit = 2; ////////////////////////////////////////////////
            reduce (); ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        ~latexshow () { ///////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * operator  () (char * b) { ///////////////////////
            return show (b); //////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////

    }; ////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class to Easily generate fancy looking tables: //////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class flowtable { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t current ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T>           L     ; //////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> names ; //////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void safefill ( size_t CLimit ) { //////////////////////////////////////////////////////////////////////////////////////////
            while ( L.size     () <= CLimit    ) { L.push_back     (0)                      ; } /////////////////////////////////////
            while ( names.size () <  L.size () ) { names.push_back (std::string("nothing")) ; } /////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void safefill ()    { safefill (current) ; } ////////////////////////////////////////////////////////////////////////
        inline void namefill ()    { if (L.size()>0) { safefill (L.size()-1) ; } } /////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void copyfrom ( const flowtable <T> & other ) { /////////////////////////////////////////////////////////////////////
            safefill (other.L.size()) ; ////////////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void*) &(L[0]) , (const void*) &(other.L[0]) , (size_t) sizeof(T) * L.size() ) ; /////////////////////////////
            current = other.current ; //////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void startover () { current = 0 ; } /////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( T val = 1 , std::string name = "noothing" ) { ///////////////////////////////////////////////////////////
            safefill () ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
            L[current]     = L[current] + val ; ////////////////////////////////////////////////////////////////////////////////////
            names[current] = name             ; ////////////////////////////////////////////////////////////////////////////////////
            current++                         ; ////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( bool val , std::string name = "nothing" ) { /////////////////////////////////////////////////////////////
            if (val) {fill(1,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
            else     {fill(0,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char * showhorizontal (std::string & linetitle) { //////////////////////////////////////////////////////////////////////////
            std::vector <std::string> parts ; /**/ { ///////////////////////////////////////////////////////////////////////////////
                std::string tmp = "\\hline " + linetitle + " &" ; //////////////////////////////////////////////////////////////////
                parts.push_back (tmp) ; ////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++){ ////////////////////////////////////////////////////////////////////////////////////////
                latexshow <T> tmplatex (L[i]) ; ////////////////////////////////////////////////////////////////////////////////////
                char tmpbuf [512] ; ////////////////////////////////////////////////////////////////////////////////////////////////
                tmplatex (tmpbuf) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                if (i<L.size()-1) {parts.push_back(std::string(tmpbuf)+" &");} /////////////////////////////////////////////////////
                else {parts.push_back(std::string(tmpbuf)+" \\\\");} ///////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            linetitle = parts[0] ; /////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=1;i<parts.size();i++){ ////////////////////////////////////////////////////////////////////////////////////
                linetitle = linetitle + parts[i] ; /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            return &(linetitle[0]) ; ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void showvals (std::vector <std::string> & outvals) { //////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++) { ///////////////////////////////////////////////////////////////////////////////////////
                latexshow <double> tmpshow (L[i]) ; ////////////////////////////////////////////////////////////////////////////////
                char tmp[128] ; tmpshow(tmp) ; /////////////////////////////////////////////////////////////////////////////////////
                outvals.push_back(std::string(tmp)); ///////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () () {startover();} //////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( T    val , std::string name = "nothing" , bool inflag = true ) { /////////////////////////////////
            if   (inflag) { fill ( val  , name ) ; } ///////////////////////////////////////////////////////////////////////////////
            else          { fill ( (T)0 , name ) ; } ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( bool val , std::string name = "nothing" ) {fill(val,name);} //////////////////////////////////////
        inline char * operator () (std::string & linetitle) {return showhorizontal(linetitle);} ////////////////////////////////////
        inline size_t size() {return L.size();} ////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return L[i];} ///////////////////////////////////////////////////////////////////////////
        inline std::vector <std::string> & operator () (std::vector <std::string> & outvals) { /////////////////////////////////////
            showvals(outvals); /////////////////////////////////////////////////////////////////////////////////////////////////////
            return outvals; ////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t operator >> (CPPFileIO::FileFD & outfile) {outfile<<L;} //////////////////////////////////////////////////////
        inline size_t operator << (CPPFileIO::FileFD & outfile) {outfile>>L;} //////////////////////////////////////////////////////
        inline void operator = (const flowtable <T> & other) {copyfrom(other);} ////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void filewrite (std::string filename) { ////////////////////////////////////////////////////////////////////////////////////
            FILE *f = fopen (&(filename[0]),"w") ; /////////////////////////////////////////////////////////////////////////////////
            namefill(); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
            size_t min_v = L.size(); ///////////////////////////////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<min_v;i++) {fprintf(f," L [%ld] = %e \t : \t %s \n",i,(double)L[i],&(names[i][0]));} /////////////////
            fclose(f); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable() { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            L.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable (const flowtable & other) { //////////////////////////////////////////////////////////////////////////////////////
            copyfrom(other); ///////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~flowtable(){} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing the Tables: ////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class flowtables { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        FILE *f ;
    public:
        void operator () (std::string infile) {
            FileLines reader(infile);
            fprintf(f,"{|");
            for (size_t i=0;i<reader.size();i++) {fprintf(f,"c|");}
            fprintf(f,"}\n");
            for (size_t i=0;i<reader();i++) {
                if(i==0) {fprintf(f,"\\hline ");}
                else {fprintf(f,"& ");}
                fprintf(f,"%s",&(reader(i)[0]));
            }
            fprintf(f," \\\\ \n");
        }
        template <typename T> void operator () (flowtable <T> & intable, std::string eventtype) {
            fprintf(f,"%s\n",intable(eventtype));
        }
        flowtables  (FILE * _f) {f=_f;fprintf(f,"\\begin{tabular}");}
        ~flowtables ()          {fprintf(f,"\\hline \\end{tabular}\n");} ///////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class LatexPrintMatrix {
    private:
        std::vector <std::string> elements ;
        size_t X, Y ;
        inline std::string & GetElement ( size_t x , size_t y ) {
            if(x>=X) {printf("BUG!!! out of bounds in x !!!\n");}
            if(y>=Y) {printf("BUG!!! out of bounds in y !!!\n");}
            return elements [x+(X*y)] ;
        }
        void Write2FILE ( FILE * f ) {
            fprintf(f,"\\begin{tabular}");
            for(size_t x=0;x<X;x++) {
                if(x==0){fprintf(f,"{|");}
                fprintf(f,"c|");
                if(x==(X-1)){fprintf(f,"}\n");}
            }
            for (size_t y=0;y<Y;y++) {
                for (size_t x=0;x<X;x++) {
                    if(x==0) {fprintf(f," \\hline %s ",&(GetElement(x,y)[0]));}
                    else     {fprintf(f," & %s ",&(GetElement(x,y)[0]));}
                }
                fprintf(f," \\\\ \n");
            }
            fprintf(f,"\\hline \\end{tabular}\n");
        }
        inline void Write2FILE ( std::string filename ) {
            FILE *f = fopen(&(filename[0]),"w");
            Write2FILE(f);
            fclose(f);
        }
    public:
        inline void operator () (std::vector <std::string> & x, size_t y) {
            size_t limit = mymin (x.size(),X) ;
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x[i];}
        }
        inline void operator () (size_t x, std::vector <std::string> & y) {
            size_t limit = mymin (y.size(),Y) ;
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y[i];}
        }
        inline void operator () (FileLines & x, size_t y) {
            size_t limit = mymin(x(),X);
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x(i);}
        }
        inline void operator () (size_t x, FileLines & y) {
            size_t limit = mymin(y(),Y);
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y(i);}
        }
        inline void operator () (FILE *f)              {Write2FILE(f);}
        inline void operator () (std::string filename) {Write2FILE(filename);}
        LatexPrintMatrix (size_t _X, size_t _Y) {
            X=_X;Y=_Y;
            elements.resize(X*Y);
        }
        ~LatexPrintMatrix(){}
    };


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Convinent multi threadable class for uniform double random number generation: ///////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class myrandgen { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T*> engines ; /////////////////////////////////////////////////////////////////////////////////////////////////
        std::uniform_real_distribution <double> dist ; /////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void allocate () { //////////////////////////////////////////////////////////////////////////////////////////////////
            std::random_device random_seeds ; //////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {engines[i]=new T(random_seeds());} ///////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        double low, high ; /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        myrandgen(size_t threads, double _low=0, double _high=1) : low(_low) , high(_high) , dist(_low,_high) { ////////////////////
            engines.resize(threads) ; //////////////////////////////////////////////////////////////////////////////////////////////
            allocate() ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~myrandgen(){ //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {delete engines[i];} //////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline double operator [] (size_t th) { ////////////////////////////////////////////////////////////////////////////////////
            double ret = dist(engines[th][0]) ; ////////////////////////////////////////////////////////////////////////////////////
            return ret ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class ToDir {
    private:
        std::string originaldir ;
        inline void godir (std::string dirname) {
            mkdir((const char*)&(dirname[0]),(mode_t)0755);
            chdir((const char*)&(dirname[0]));
        }
        bool goback ;
    public:
        inline void operator () (std::string dirname) {godir(dirname);}
        inline void operator () (const char *dirname) {godir(std::string(dirname));}
        inline void operator () (long innum) {
            char tmp[128] ;
            sprintf(tmp,"%ld",innum);
            godir(std::string(tmp));
        }
        inline void operator () () {godir(originaldir);}
        inline void showdir() {
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            printf("%s\n",tmp);
        }
        inline std::string getoriginal () {return originaldir;}
        ToDir(bool _goback=false){
            goback = _goback ;
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            originaldir = std::string(tmp);
            std::cout << originaldir << "\n" ;
        }
        ~ToDir(){if(goback){godir(originaldir);}}
    };


} //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace NeuralNetworks { /////////////////////////////////////////////////////////////////////////////////////////////////////////
    const float AlphaG  = 0.5            ;
    const float epsG    = 0.0000001      ;
    const float Beta[3] = {0.9,0.99,0.7} ;

    typedef float TypeFloat ;


    template < typename T = TypeFloat > class MyMatrix ;
    template < typename T = TypeFloat > class Matrix3D ;

    template < typename T = TypeFloat > class MyVector {
    private:
        std::vector <T> store ;
        inline void copyfrom (T*ptr) {memcpy((void*)&(store[0]),(const void*)ptr,(size_t)store.size()*sizeof(T));}
        inline void copyfrom (MyVector<T>&other) {
            minsize(other.store.size());
            memcpy((void*)&(store[0]),(const void*)&(other.store[0]),(size_t)other.store.size()*sizeof(T));
        }
    public:
        inline T L2Norm () {T sum=0;for(size_t i=0;i<store.size();i++){sum=sum+(store[i]*store[i]);}return sum;}
        inline T L1Norm () {T sum=0;for(size_t i=0;i<store.size();i++){sum=sum+CPPFileIO::mymod(store[i]);}return sum;}
        inline T Sum2   () {return L1Norm();}
        inline void Assign(T in){for(size_t i=0;i<store.size();i++){store[i]=in;}}
        inline void multiply (T val) {for(size_t i=0;i<store.size();i++){store[i]=store[i]*val;}}
        inline T GetAvg () {
            T ret=0 ;
            for (size_t i=0;i<store.size();i++) {ret=ret+store[i];}
            return ret ;
        }
        inline void ZeroAll () {Assign(0.0);}
        inline size_t size() {return store.size();}
        inline T & operator () (size_t i) {return store[i];}
        inline void operator () (MyMatrix<T>&A,MyVector<T>&X,MyVector<T>&B) {
            resize(A.sizeY());
            for (size_t y=0;y<A.sizeY();y++) {
                store[y]=B(y);
                for (size_t x=0;x<A.sizeX();x++) {store[y]=store[y]+(A(y,x)*X(x));}
            }
        }
        inline T & operator [] (size_t i) {return store[i];}
        inline void subtract (MyVector<T>&other,T val) {
            resize (other.size()) ;
            for (size_t i=0;i<store.size();i++) {store[i]=store[i]-(other[i]*val);}
        }
        inline void subtract (MyVector<T>&other) {
            resize (other.size()) ;
            for (size_t i=0;i<store.size();i++) {store[i]=store[i]-(other[i]);}
        }
        inline void subtract (MyVector<T>&other1,MyVector<T>&other2) {
            if(other1.size()==other2.size()) {
                resize(other1.size());
                for(size_t i=0;i<store.size();i++) {store[i]=(other1[i])-(other2[i]);}
            }
        }
        inline void operator = (T other)           { Assign   (other) ; }
        inline void operator = (T*other)           { copyfrom (other) ; }
        inline void operator = (MyVector<T>&other) { copyfrom (other) ; }
        inline void minsize (size_t i) { if ( i >  store.size () ) {store.resize(i);} }
        inline void resize  (size_t i) { if ( i != store.size () ) {store.resize(i);} }
        MyVector(){}
        ~MyVector(){}
    };
    template < typename T             > class MyMatrix {
    private:
        MyVector <T>  store ;
        size_t X, Y;
        inline T & GetElement (size_t _Y, size_t _X) {return store[_X+(X*_Y)];}
    public:
        inline void Assign(T in){store.Assign(in);}
        inline T Sum2(){return store.Sum2();}
        inline void multiply (T num) {store.multiply(num);}
        inline T GetAvg () {return store.GetAvg();}
        inline void ZeroAll () {store.ZeroAll();}
        inline T & operator () (size_t _Y, size_t _X) {return GetElement(_Y,_X);}
        inline void resize (size_t _Y, size_t _X) {if((X!=_X)||(Y!=_Y)) {X=_X;Y=_Y;store.resize(X*Y);}}
        inline T & operator [] (size_t i) {return store[i];}
        inline void operator = (MyMatrix&other) {resize(other.sizeX(),other.sizeY());store=other.store;}
        inline size_t sizeX () {return X;}
        inline size_t sizeY () {return Y;}
        inline size_t size  () {return store.size();}
        inline void subtract (MyMatrix<T>&other,T val) {store.subtract(other.store,val);}
        inline void multiple (MyMatrix<T>&A,MyMatrix<T>&B) {
            {resize(A.sizeY(),B.sizeX());ZeroAll();}
            for(size_t y=0;y<Y;y++)for(size_t t=0;t<A.sizeX();t++)for(size_t x=0;x<X;x++)
            {GetElement(y,x)=GetElement(y,x)+(A(y,t)*B(t,x));}
        }
        MyMatrix(){}
        ~MyMatrix(){}
    };
    template < typename T             > class Matrix3D {
    private:
        MyMatrix <T> store ;
        size_t X, Y, Z;
    public:
        inline void Assign(T in){store.Assign(in);}
        inline T      GetAvg  () {return store.GetAvg();}
        inline void   ZeroAll () {store.ZeroAll();}
        inline size_t sizeX   () {return X;}
        inline size_t sizeY   () {return Y;}
        inline size_t sizeZ   () {return Z;}
        inline size_t size    () {return store.size();}
        inline void   resize  (size_t _Z, size_t _Y, size_t _X) {
            if ((_X!=X)||(_Y!=Y)||(_Z!=Z)) {
                {X=_X; Y=_Y; Z=_Z;}
                store.resize(Z,X*Y);
            }
        }
        inline T & operator () (size_t _Z, size_t _Y, size_t _X) {
            return store(_Z,_X+(X*_Y));
        }
        Matrix3D(){}
        ~Matrix3D(){}
    };

    typedef MyVector <> GoodVector   ;
    typedef MyMatrix <> GoodMatrix   ;
    typedef Matrix3D <> GoodMatrix3D ;

    template < typename T = TypeFloat > class Activate_Sigmoid {
    private:
        inline void activate (MyVector<T>&A,MyVector<T>&B) {
            B.resize(A.size());
            for (size_t x=0;x<A.size();x++) {
                T tmp = A(x) ;
                if ( tmp >  5 ) { tmp =  5 ; }
                if ( tmp < -5 ) { tmp = -5 ; }
                tmp = 1.0 / ( 1.0 + exp(-tmp) ) ;
                A(x) = tmp ;
                tmp = tmp*(1.0-tmp) ;
                if (tmp<0.001) {tmp=0.001;}
                B(x) = tmp ;
            }
        }
    public:
        inline void operator () (MyVector<T>&A,MyVector<T>&B) {activate(A,B);}
        Activate_Sigmoid  () {}
        ~Activate_Sigmoid () {}
    };
    template < typename T = TypeFloat > class SoftSign         {
    private:
        inline void activate (MyVector<T>&A,MyVector<T>&B) {
            B.resize(A.size());
            for (size_t x=0;x<A.size();x++) {
                T tmp = CPPFileIO::mymod (A[x]) ;
                B[x] = 1.0 / ( 1.0 + tmp ) ;
                A[x] = A[x] * B[x] ;
                B[x] = B[x] * B[x] ;
                if (B[x]<0.001) {B[x]=0.001;}
            }
        }
    public:
        inline void operator () (MyVector<T>&A,MyVector<T>&B) {activate(A,B);}
        SoftSign  () {}
        ~SoftSign () {}
    };
    template < typename T = TypeFloat > class Activate_LRU     {
    private:
        inline void activate (MyVector<T>&A,MyVector<T>&B) {
            B.resize(A.size());
            for (size_t x=0;x<A.size();x++) {
                if (A(x)<0) {B(x)=0.01;A(x)=0.0;} else {B(x)=1;}
            }
        }
    public:
        inline void operator () (MyVector<T>&A,MyVector<T>&B) {activate(A,B);}
        Activate_LRU  () {}
        ~Activate_LRU () {}
    };
    template < typename T = TypeFloat > class Activate_ID      {
    private:
        inline void activate (MyVector<T>&A,MyVector<T>&B)
        { B.resize(A.size()); for(size_t x=0;x<A.size();x++) {B(x)=1.0;} }
    public:
        inline void operator () (MyVector<T>&A,MyVector<T>&B) {activate(A,B);}
        Activate_ID  () {}
        ~Activate_ID () {}
    };
    template < typename T = TypeFloat > class SoftLRU          {
    private:
        inline void activate (MyVector<T>&A,MyVector<T>&B) {
            B.resize(A.size());
            for (size_t i=0;i<A.size();i++) {
                if (A[i]<0) {
                    B[i] = 1.0 / ( 1.0 - A[i] ) ;
                    A[i] = A[i] * B[i] ;
                    B[i] = B[i] * B[i] ;
                    if (B[i]<0.001) {B[i]=0.001;}
                } else {B[i]=1.0;}
            }
        }
    public:
        inline void operator () (MyVector<T>&A,MyVector<T>&B) {activate(A,B);}
        SoftLRU  () {}
        ~SoftLRU () {}
    };

    typedef Activate_Sigmoid <> GoodActivate_Sigmoid ;
    typedef SoftSign         <> GoodSoftSign         ;
    typedef Activate_LRU     <> GoodActivate_LRU     ;
    typedef Activate_ID      <> GoodActivate_ID      ;
    typedef SoftLRU          <> GoodSoftLRU          ;

    template < typename T2 , typename T  = TypeFloat > class AdaMax        {
    private:
        T2 * tgt ;
        T2   M, V ;
        T2   Changes ;
        T    BetaT[1] ;

        inline void ZeroAll(){M.ZeroAll();V.ZeroAll();Changes.ZeroAll();}
        inline void work_slave1(MyMatrix<T>&other){other.resize(tgt->sizeY(),tgt->sizeX());other.ZeroAll();}
        inline void work_slave1(MyVector<T>&other){other.resize(tgt->size());other.ZeroAll();}
        inline void MultiplyAssign(T2&Dst,T2&Src,T val){for(size_t i=0;i<Dst.size();i++){Dst[i]=Src[i]*val;}}
        inline void AdamAssign(T2&m,T2&v,T eta,const T eps)
        {for(size_t i=0;i<tgt->size();i++){tgt[0][i]=tgt[0][i]-(eta*m[i]/(v[i]+eps));}}
        inline void addup(size_t y, size_t x, T val) {Changes(y,x)=Changes(y,x)+val;}
        inline void addup(size_t y, T val) {Changes[y]=Changes[y]+val;}
        inline void assign (T2&_tgt) {
            tgt = & (_tgt) ;
            work_slave1(M);work_slave1(V);
            work_slave1(Changes);
            ZeroAll();
        }
        inline void apply (T eta) {
            const T eps = (T)epsG ;
            for (size_t i=0;i<Changes.size();i++) {
                M[i] = (M[i]*Beta[0]) + ((1.0-Beta[0])*Changes[i]) ;
                V[i] = CPPFileIO::mymax( V[i]*Beta[1] , CPPFileIO::mymod(Changes[i]) );
            }
            BetaT[0]=BetaT[0]*Beta[0];
            AdamAssign(M,V,eta/(1.0-BetaT[0]),eps);
            Changes.ZeroAll();
        }
    public:
        inline size_t size  () { return tgt->size  () ; }
        inline size_t sizeX () { return tgt->sizeX () ; }
        inline size_t sizeY () { return tgt->sizeY () ; }
        inline void operator () (T2&_tgt) {assign(_tgt);}
        inline void operator () (T eta) {apply(eta);}
        inline void operator () (size_t y,size_t x,T val) {addup(y,x,val);}
        inline void operator () (size_t y,T val) {addup(y,val);}
        inline void operator () () {ZeroAll();}
        AdaMax(){BetaT[0]=1.0;BetaT[1]=1.0;}
        ~AdaMax(){}
    };
    template < typename T2 , typename T  = TypeFloat > class Adamize       {
    private:
        T2 * tgt ;
        T2   M, V ;
        T2   Mhat, Vhat ;
        T2   Changes ;
        T    BetaT[2] ;

        inline void ZeroAll(){M.ZeroAll();V.ZeroAll();Mhat.ZeroAll();Vhat.ZeroAll();Changes.ZeroAll();}
        inline void work_slave1(MyMatrix<T>&other){other.resize(tgt->sizeY(),tgt->sizeX());other.ZeroAll();}
        inline void work_slave1(MyVector<T>&other){other.resize(tgt->size());other.ZeroAll();}
        inline void MultiplyAssign(T2&Dst,T2&Src,T val){for(size_t i=0;i<Dst.size();i++){Dst[i]=Src[i]*val;}}
        inline void AdamAssign(T2&m,T2&v,T eta,const T eps)
        {for(size_t i=0;i<tgt->size();i++){tgt[0][i]=tgt[0][i]-(eta*(m[i])/((sqrt(v[i]))+eps));}}
        inline void addup(size_t y, size_t x, T val) {Changes(y,x)=Changes(y,x)+val;}
        inline void addup(size_t y, T val) {Changes[y]=Changes[y]+val;}
        inline void assign (T2&_tgt) {
            tgt = & (_tgt) ;
            work_slave1(M);work_slave1(Mhat);
            work_slave1(V);work_slave1(Vhat);
            work_slave1(Changes);
            ZeroAll();
        }
        inline void apply (T eta) {
            const T eps = (T)epsG ;
            for (size_t i=0;i<Changes.size();i++) {
                M[i]=(M[i]*Beta[0])+((1-Beta[0])*Changes[i]);
                V[i]=(V[i]*Beta[1])+((1-Beta[1])*Changes[i]*Changes[i]);
            }
            BetaT[0]=BetaT[0]*Beta[0];
            BetaT[1]=BetaT[1]*Beta[1];
            MultiplyAssign(Mhat,M,(T)1.0/(1.0-BetaT[0]));
            MultiplyAssign(Vhat,V,(T)1.0/(1.0-BetaT[1]));
            AdamAssign(Mhat,Vhat,eta,eps);
            Changes.ZeroAll();
        }
    public:
        inline size_t size  () { return tgt->size  () ; }
        inline size_t sizeX () { return tgt->sizeX () ; }
        inline size_t sizeY () { return tgt->sizeY () ; }
        inline void operator () (T2&_tgt) {assign(_tgt);}
        inline void operator () (T eta) {apply(eta);}
        inline void operator () (size_t y,size_t x,T val) {addup(y,x,val);}
        inline void operator () (size_t y,T val) {addup(y,val);}
        inline void operator () () {ZeroAll();}
        Adamize(){BetaT[0]=1.0;BetaT[1]=1.0;}
        ~Adamize(){}
    };
    template < typename T2 , typename T  = TypeFloat > class AdaReg        {
    private:
        T2 * tgt ;
        T2   M, V ;
        T2   Mhat, Vhat ;
        T2   Changes  ;
        T2   ChangesM ;
        T    BetaT[2] ;

        inline void ZeroAll(){M.ZeroAll();V.ZeroAll();Mhat.ZeroAll();Vhat.ZeroAll();Changes.ZeroAll();ChangesM.ZeroAll();}
        inline void work_slave1(MyMatrix<T>&other){other.resize(tgt->sizeY(),tgt->sizeX());other.ZeroAll();}
        inline void work_slave1(MyVector<T>&other){other.resize(tgt->size());other.ZeroAll();}
        inline void MultiplyAssign(T2&Dst,T2&Src,T val){for(size_t i=0;i<Dst.size();i++){Dst[i]=Src[i]*val;}}
        inline void AdamAssign(T2&m,T2&v,T eta,const T eps) {
            for(size_t i=0;i<tgt->size();i++){
                float rate1 = eta * CPPFileIO::mymod(Changes[i]) / ChangesM[i] ;
                float rate2 = m[i] / (sqrt(v[i])+eps) ;
                tgt[0][i] = tgt[0][i] - (rate1*rate2) ;
            }
        }
        inline void addup(size_t y, size_t x, T val) {
            Changes(y,x)  = Changes(y,x)  + val                   ;
            ChangesM(y,x) = ChangesM(y,x) + CPPFileIO::mymod(val) ;
        }
        inline void addup(size_t y, T val) {
            Changes[y]  = Changes[y]  + val                   ;
            ChangesM[y] = ChangesM[y] + CPPFileIO::mymod(val) ;
        }
        inline void assign (T2&_tgt) {
            tgt = & (_tgt) ;
            work_slave1(M); work_slave1(Mhat);
            work_slave1(V); work_slave1(Vhat);
            work_slave1(Changes); work_slave1(ChangesM);
            ZeroAll();
        }
        inline void apply (T eta) {
            const T eps = (T)epsG ;
            for (size_t i=0;i<Changes.size();i++) {
                M[i]=(M[i]*Beta[0])+((1-Beta[0])*Changes[i]);
                V[i]=(V[i]*Beta[1])+((1-Beta[1])*Changes[i]*Changes[i]);
            }
            BetaT[0]=BetaT[0]*Beta[0];
            BetaT[1]=BetaT[1]*Beta[1];
            MultiplyAssign(Mhat,M,(T)1.0/(1.0-BetaT[0]));
            MultiplyAssign(Vhat,V,(T)1.0/(1.0-BetaT[1]));
            AdamAssign(Mhat,Vhat,eta,eps);
            Changes.ZeroAll(); ChangesM.ZeroAll();
        }
    public:
        inline size_t size  () { return tgt->size  () ; }
        inline size_t sizeX () { return tgt->sizeX () ; }
        inline size_t sizeY () { return tgt->sizeY () ; }
        inline void operator () (T2&_tgt) {assign(_tgt);}
        inline void operator () (T eta) {apply(eta);}
        inline void operator () (size_t y,size_t x,T val) {addup(y,x,val);}
        inline void operator () (size_t y,T val) {addup(y,val);}
        inline void operator () () {ZeroAll();}
        AdaReg(){BetaT[0]=1.0;BetaT[1]=1.0;}
        ~AdaReg(){}
    };
    template < typename T2 , typename T  = TypeFloat > class MomentumDelta {
    private:
        T2 * tgt ;
        T2   vel ;
        inline void assign (MyMatrix <T> & _tgt) {
            tgt = & (_tgt) ;
            vel.resize(tgt->sizeY(),tgt->sizeX());
            vel.ZeroAll();
        }
        inline void assign (MyVector <T> & _tgt) {
            tgt = & (_tgt) ;
            vel.resize(tgt->size());
            vel.ZeroAll();
        }
        inline void apply (T eta) {
            T sum=vel.Sum2()+epsG;
            tgt->subtract(vel,eta/sum);
            const T alpha=(T)AlphaG;
            vel.multiply(alpha);
        }
        inline void addup (size_t y, size_t x, T val) {vel(y,x)=vel(y,x)+val;}
        inline void addup (size_t x, T val) {vel[x]=vel[x]+val;}
    public:
        inline size_t size  () { return vel.size  () ; }
        inline size_t sizeX () { return vel.sizeX () ; }
        inline size_t sizeY () { return vel.sizeY () ; }
        inline void operator () (MyVector <T> & _tgt) {assign(_tgt);}
        inline void operator () (MyMatrix <T> & _tgt) {assign(_tgt);}
        inline void operator () (T eta) {apply(eta);}
        inline void operator () (size_t x, T val) {addup(x,val);}
        inline void operator () (size_t y, size_t x, T val) {addup(y,x,val);}
        inline void operator () () {vel.ZeroAll();}
        MomentumDelta  () {}
        ~MomentumDelta () {}
    };

    typedef AdaReg        < GoodVector > GoodAdaRegVector        ;
    typedef AdaReg        < GoodMatrix > GoodAdaRegMatrix        ;
    typedef AdaMax        < GoodVector > GoodAdaMaxVector        ;
    typedef AdaMax        < GoodMatrix > GoodAdaMaxMatrix        ;
    typedef Adamize       < GoodVector > GoodAdamizeVector       ;
    typedef Adamize       < GoodMatrix > GoodAdamizeMatrix       ;
    typedef MomentumDelta < GoodVector > GoodMomentumDeltaVector ;
    typedef MomentumDelta < GoodMatrix > GoodMomentumDeltaMatrix ;

    template < size_t depth , typename TF = TypeFloat > class Parameters {
    private:
        inline void WriteToFile (FILE*F) {
            for(size_t K=0;K<depth;K++) {
                for ( size_t i = 0 ; i < weight[K].size () ; i++ ) {fprintf(F,"pars.weight[%ld][%ld]=%e;",K,i,weight[K][i]);}
                fprintf(F,"\n");
                for ( size_t i = 0 ; i < bias[K].size   () ; i++ ) {fprintf(F,"pars.bias[%ld][%ld]=%e;",K,i,bias[K][i]);}
                fprintf(F,"\n");
            }
        }
        inline void WriteToFile (std::string FileName) {FILE*f=fopen(&(FileName[0]),"w");WriteToFile(f);fclose(f);}
        inline void initialize () {
            for(size_t K=0;K<depth;K++) {
                weight[K+0].resize ( sizes [K+1] , sizes [K+0] ) ;
                bias[K+0].resize   ( sizes [K+1]               ) ;
            }
        }
        template <typename TR> inline void Randomize (CPPFileIO::myrandgen <TR> & engine) {
            for (size_t K=0;K<depth;K++) {
                for ( size_t i = 0 ; i < weight[K].size () ; i++ ) { weight [K][i] = engine[0] ; }
                for ( size_t i = 0 ; i < bias[K].size   () ; i++ ) { bias   [K][i] = engine[0] ; }
            }
        }
    public:
        MyVector <TF> bias   [ depth     ] ;
        MyMatrix <TF> weight [ depth     ] ;
        size_t        sizes  [ depth + 1 ] ;
        template <typename TR> inline void operator () (CPPFileIO::myrandgen<TR>&engine) {Randomize(engine);}
        inline void operator () (                        ) { initialize  (          ) ; }
        inline void operator () ( std::string   filename ) { WriteToFile ( filename ) ; }
        inline void operator () ( FILE        * F        ) { WriteToFile ( F        ) ; }
        Parameters  () {}
        ~Parameters () {}
    };

    template < typename TDW = GoodAdaRegMatrix , typename TDB = GoodAdaRegVector , typename TF = TypeFloat >
    class FCNN {
    private:
        size_t                        depth       ;
        size_t                        count       ;
        std::vector  <TDW>            DeltaW      ;
        std::vector  <TDB>            DeltaB      ;
        std::vector  <MyVector<TF>>   Layers      ;
        std::vector  <MyVector<TF>>   Derivs      ;
        std::vector  <MyVector<TF>>   Chain       ;
        MyMatrix     <TF>           * weight      ;
        MyVector     <TF>           * bias        ;
        MyVector     <TF>             TrainDeltas ;
        SoftSign     <TF>             actsig      ;
        SoftLRU      <TF>             actlru      ;
        //Activate_Sigmoid <TF>             actsig      ;
        //Activate_LRU     <TF>             actlru      ;
        TF                            AvgError    ;
        inline MyVector <TF> & Diffs  ( size_t i ) {return Derivs[i];}
        inline void resize(size_t i){
            Output(i).resize (weight[i].sizeY()) ;
            Input(i).resize  (weight[i].sizeX()) ;
            DeltaW[i](weight[i]); DeltaB[i](bias[i]);
        }
        inline void initialize(MyMatrix<TF>*_weight,MyVector<TF>*_bias){
            {weight=_weight;bias=_bias;}
            for(size_t i=0;i<depth;i++){resize(i);}
            {TrainDeltas.resize(Output().size());}
        }
        inline void initialize(size_t _depth){
            /* Initialize default values: */ {
                depth    = _depth ;
                count    = 0      ;
                AvgError = 0      ;
            }
            /* Resize Standard arrays: */ {
                DeltaW.resize ( depth     ) ;
                DeltaB.resize ( depth     ) ;
                Layers.resize ( depth + 1 ) ;
                Derivs.resize ( depth     ) ;
                Chain.resize  ( depth     ) ;
            }
        }
        template <size_t T> inline void initialize (Parameters<T,TF>&inpars) {initialize(T);initialize(inpars.weight,inpars.bias);}
        template <typename T> inline void activate (size_t i,T&Activator){
            Output(i) ( weight[i] , Input(i) , bias[i] ) ;
            Activator ( Output(i) , Diffs(i)           ) ;
        }
        inline TF P (size_t L, size_t i, size_t j) {return Diffs(L)(i)*weight[L](i,j);}
        inline void EvalChain(size_t K){
            if(K<(depth)){
                if ( K == (depth-1) ) {
                    Chain[K].resize(weight[K].sizeX()); Chain[K].ZeroAll();
                    for(size_t i=0;i<weight[K].sizeY();i++)for(size_t m=0;m<weight[K].sizeX();m++)
                    {Chain[K](m)=Chain[K](m)+(TrainDeltas(i)*P(K,i,m));}
                } else if ( K < (depth-1) ) {
                    Chain[K].resize(weight[K].sizeX()); Chain[K].ZeroAll();
                    for(size_t i=0;i<weight[K].sizeY();i++)for(size_t m=0;m<weight[K].sizeX();m++)
                    {Chain[K](m)=Chain[K](m)+(Chain[K+1](i)*P(K,i,m));}
                }
            }
            if(K>0){EvalChain(K-1);}
        }
        inline TF D (size_t  K, size_t  m, size_t  n){
            if(K==(depth-1)){return (TrainDeltas(m))*(Diffs(K)(m))*(Input(K)(n));}
            else if(K<(depth-1)){return (C(K+1,m))*(Diffs(K)(m))*(Input(K)(n));}
        }
        inline TF D (size_t K, size_t m){
            if(K==(depth-1)){return TrainDeltas(m);}
            else if(K<(depth-1)){return C(K+1,m);}
        }
        inline void activate(){
            for(size_t i=0;i<depth-1;i++){activate(i,actlru);}
            activate(depth-1,actsig);
        }
        inline TF Apply (TF eta) {
            if(count>0){
                for(size_t i=0;i<DeltaW.size();i++){DeltaW[i]((TF)eta/count);}
                for(size_t i=0;i<DeltaB.size();i++){DeltaB[i]((TF)eta/count);}
            }
            TF ret = AvgError ; count = 0 ; AvgError = 0 ;
            return ret ;
        }
        inline void Train(size_t K, size_t m, size_t n) {DeltaW[K](m,n,D(K,m,n));}
        inline void Train(size_t K, size_t m)           {DeltaB[K](m,D(K,m));}
        inline void Train(size_t K=0){
            if(K<depth) {
                for(size_t y=0;y<DeltaW[K].sizeY();y++)for(size_t x=0;x<DeltaW[K].sizeX();x++){Train(K,y,x);}
                for(size_t x=0;x<DeltaB[K].size();x++){Train(K,x);}
                Train(K+1);
            }
        }
        inline void Train (MyVector<TF>&answers) {TrainDeltas.subtract(Output(),answers);TrainOnDelta();}
        inline void WriteToFile (FILE*F) {
            for(size_t K=0;K<depth;K++) {
                for(size_t i=0;i<weight[K].size();i++) {fprintf(F,"weight[%ld][%ld]=%e;",K,i,weight[K][i]);}
                fprintf(F,"\n");
                for(size_t i=0;i<bias[K].size();i++) {fprintf(F,"bias[%ld][%ld]=%e;",K,i,bias[K][i]);}
                fprintf(F,"\n");
            }
        }
        inline void WriteToFile (std::string FileName) {FILE*f=fopen(&(FileName[0]),"w");WriteToFile(f);fclose(f);}
    public:
        inline void TrainOnDelta      (            )
        {EvalChain();Train();count++;AvgError=AvgError+TrainDeltas.L1Norm();}
        inline void EvalChain         (            ) { EvalChain          (depth-1) ; }
        inline MyVector <TF> & GetD   (            ) { return TrainDeltas           ; }
        inline TF            & GetD   ( size_t i   ) { return TrainDeltas ( i     ) ; }
        inline MyVector <TF> & Input  ( size_t i=0 ) { return Layers      [ i     ] ; }
        inline MyVector <TF> & Output ( size_t i   ) { return Layers      [ i + 1 ] ; }
        inline MyVector <TF> & Output (            ) { return Layers      [ depth ] ; }
        inline MyVector <TF> & C      ( size_t L   ) { return Chain       [ L     ] ; }
        inline TF            & C      ( size_t L, size_t j) {return Chain[L](j);}
        inline void operator () () {activate();}
        inline void operator () (MyMatrix<TF>*_weight,MyVector<TF>*_bias) {initialize(_weight,_bias);}
        inline void operator () (MyVector<TF>&answers) {Train(answers);}
        inline void operator () (TF eta) {Apply(eta);}
        inline void operator () (std::string filename) {WriteToFile(filename);}
        inline void operator () (FILE*F) {WriteToFile(F);}
        template <size_t T> inline void operator () (Parameters<T,TF>&inpars) {initialize(inpars);}

        template <size_t T> FCNN (Parameters<T,TF>&inpars) {initialize(inpars);}
        FCNN  (size_t _depth=0) {initialize(_depth);}
        ~FCNN ()              {}
    };

    template < size_t depth = 3 , typename TDW = GoodAdaRegMatrix , typename TDB = GoodAdaRegVector , typename TF = TypeFloat >
    class FCNN2 {
    private:
        size_t          count                ;
        TF              AvgError             ;
        TDW             DeltaW [ depth     ] ;
        TDB             DeltaB [ depth     ] ;
        MyVector <TF>   Layers [ depth + 1 ] ;
        MyVector <TF>   Derivs [ depth     ] ;
        MyVector <TF>   Chain  [ depth     ] ;
        MyMatrix <TF> * weight               ;
        MyVector <TF> * bias                 ;
        MyVector <TF>   TrainDeltas          ;
        SoftSign <TF>   actsig               ;
        SoftLRU  <TF>   actlru               ;
        //Activate_Sigmoid <TF>             actsig      ;
        //Activate_LRU     <TF>             actlru      ;

        inline MyVector <TF> & Diffs  ( size_t i ) {return Derivs[i];}
        inline void resize(size_t i){
            Output(i).resize (weight[i].sizeY()) ;
            Input(i).resize  (weight[i].sizeX()) ;
            DeltaW[i](weight[i]); DeltaB[i](bias[i]);
        }
        inline void initialize(){
            /* Initialize default values: */ {
                count    = 0 ;
                AvgError = 0 ;
            }
        }
        inline void initialize(MyMatrix<TF>*_weight,MyVector<TF>*_bias){
            initialize();
            {weight=_weight;bias=_bias;}
            for(size_t i=0;i<depth;i++){resize(i);}
            {TrainDeltas.resize(Output().size());}
        }
        inline void initialize (Parameters<depth,TF>&inpars) {initialize(inpars.weight,inpars.bias);}
        inline void WriteToFile (FILE*F) {
            for(size_t K=0;K<depth;K++) {
                for(size_t i=0;i<weight[K].size();i++) {fprintf(F,"weight[%ld][%ld]=%e;",K,i,weight[K][i]);}
                fprintf(F,"\n");
                for(size_t i=0;i<bias[K].size();i++) {fprintf(F,"bias[%ld][%ld]=%e;",K,i,bias[K][i]);}
                fprintf(F,"\n");
            }
        }
        inline void WriteToFile (std::string FileName) {FILE*f=fopen(&(FileName[0]),"w");WriteToFile(f);fclose(f);}

        template <typename T> inline void activate (size_t i,T&Activator){
            Output(i) ( weight[i] , Input(i) , bias[i] ) ;
            Activator ( Output(i) , Diffs(i)           ) ;
        }
        inline TF P (size_t L, size_t i, size_t j) {return Diffs(L)(i)*weight[L](i,j);}
        inline void EvalChain(size_t K){
            if(K<(depth)){
                if ( K == (depth-1) ) {
                    Chain[K].resize(weight[K].sizeX()); Chain[K].ZeroAll();
                    for(size_t i=0;i<weight[K].sizeY();i++)for(size_t m=0;m<weight[K].sizeX();m++)
                    {Chain[K](m)=Chain[K](m)+(TrainDeltas(i)*P(K,i,m));}
                } else if ( K < (depth-1) ) {
                    Chain[K].resize(weight[K].sizeX()); Chain[K].ZeroAll();
                    for(size_t i=0;i<weight[K].sizeY();i++)for(size_t m=0;m<weight[K].sizeX();m++)
                    {Chain[K](m)=Chain[K](m)+(Chain[K+1](i)*P(K,i,m));}
                }
            }
            if(K>0){EvalChain(K-1);}
        }
        inline TF D (size_t  K, size_t  m, size_t  n){
            if(K==(depth-1)){return (TrainDeltas(m))*(Diffs(K)(m))*(Input(K)(n));}
            else if(K<(depth-1)){return (C(K+1,m))*(Diffs(K)(m))*(Input(K)(n));}
        }
        inline TF D (size_t K, size_t m){
            if(K==(depth-1)){return TrainDeltas(m);}
            else if(K<(depth-1)){return C(K+1,m);}
        }
        inline void activate(){
            for(size_t i=0;i<depth-1;i++){activate(i,actlru);}
            activate(depth-1,actsig);
        }
        inline TF Apply (TF eta) {
            if(count>0){
                for(size_t i=0;i<DeltaW.size();i++){DeltaW[i]((TF)eta/count);}
                for(size_t i=0;i<DeltaB.size();i++){DeltaB[i]((TF)eta/count);}
            }
            TF ret = AvgError ; count = 0 ; AvgError = 0 ;
            return ret ;
        }
        inline void Train(size_t K, size_t m, size_t n) {DeltaW[K](m,n,D(K,m,n));}
        inline void Train(size_t K, size_t m)           {DeltaB[K](m,D(K,m));}
        inline void Train(size_t K=0){
            if(K<depth) {
                for(size_t y=0;y<DeltaW[K].sizeY();y++)for(size_t x=0;x<DeltaW[K].sizeX();x++){Train(K,y,x);}
                for(size_t x=0;x<DeltaB[K].size();x++){Train(K,x);}
                Train(K+1);
            }
        }
        inline void Train (MyVector<TF>&answers) {TrainDeltas.subtract(Output(),answers);TrainOnDelta();}

    public:
        inline void TrainOnDelta      (            )
        {EvalChain();Train();count++;AvgError=AvgError+TrainDeltas.L1Norm();}

        inline void EvalChain         (                    ) { EvalChain          (depth-1)    ; }
        inline MyVector <TF> & GetD   (                    ) { return TrainDeltas              ; }
        inline TF            & GetD   ( size_t i           ) { return TrainDeltas ( i     )    ; }
        inline MyVector <TF> & Input  ( size_t i=0         ) { return Layers      [ i     ]    ; }
        inline MyVector <TF> & Output ( size_t i           ) { return Layers      [ i + 1 ]    ; }
        inline MyVector <TF> & Output (                    ) { return Layers      [ depth ]    ; }
        inline MyVector <TF> & C      ( size_t L           ) { return Chain       [ L     ]    ; }
        inline TF            & C      ( size_t L, size_t j ) { return Chain       [ L     ](j) ; }

        inline void operator () () {activate();}
        inline void operator () (MyMatrix<TF>*_weight,MyVector<TF>*_bias) {initialize(_weight,_bias);}
        inline void operator () (MyVector<TF>&answers) {Train(answers);}
        inline void operator () (TF eta) {Apply(eta);}
        inline void operator () (std::string filename) {WriteToFile(filename);}
        inline void operator () (FILE*F) {WriteToFile(F);}
        inline void operator () (Parameters<depth,TF>&inpars) {initialize(inpars);}

        template <size_t T> FCNN2 (Parameters<T,TF>&inpars) {initialize(inpars);}
        FCNN2  (size_t _depth=0) {initialize(_depth);}
        ~FCNN2 ()              {}
    };


    typedef FCNN <> GoodFCNN              ;
} //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif
