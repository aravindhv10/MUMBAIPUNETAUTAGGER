#ifndef CPPFileIO_HH
#define CPPFileIO_HH
/////////////////////////
#include <stdio.h> //////
#include <time.h>   /////
#include <stdlib.h> /////
#include <string.h> /////
#include <sys/types.h> //
#include <sys/wait.h> ///
#include <sys/stat.h> ///
#include <sys/mman.h> ///
#include <fcntl.h> //////
#include <unistd.h> /////
#include <math.h> ///////
#include <string.h> /////
/////////////////////////
#include <iostream> /////
#include <vector> ///////
#include <algorithm> ////
#include <random> ///////
/////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
namespace CPPFileIO { //////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pointer Management: /////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    const char junk_address = '0' ; ////////////////////////////////////////////////////////////////////////////////////////////////
    const bool DEBUG = false; //////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline void set_junked  ( T * & inptr ) { inptr=(T*)(&junk_address);} ////////////////////////////////////
    template <typename T> inline bool is_junked   ( T * & inptr ) { return (inptr==(T*)(&junk_address));} //////////////////////////
    template <typename T> inline bool safe_delete ( T * & inptr ) { ////////////////////////////////////////////////////////////////
        if (!is_junked(inptr)) { delete inptr; set_junked(inptr); return true; } else {return false;} //////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline bool safe_delete_array ( T * & inptr ) { //////////////////////////////////////////////////////////
        if (!is_junked(inptr)) { delete[] inptr; set_junked(inptr); return true; } else {return false;} ////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    inline size_t shifter  (size_t in) {return (1<<in);} ///////////////////////////////////////////////////////////////////////////
    inline bool   checkbit (size_t inbits, size_t checkbits) {return ((inbits&checkbits)==checkbits);} /////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    size_t NTHREADS = 4 ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Useful template functions : /////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T    mymod  ( T   a         ) { if (a<0) { return -a ; } else { return a ; } } ////////////////////
    template <typename T> inline T    mymax  ( T   a , T   b ) { if (a<b) { return  b ; } else { return a ; } } ////////////////////
    template <typename T> inline T    mymin  ( T   a , T   b ) { if (a<b) { return  a ; } else { return b ; } } ////////////////////
    template <typename T> inline T    mysign ( T   a         ) { if (a<0) { return -1 ; } else { return 1 ; } } ////////////////////
    template <typename T> inline void myswap ( T & a , T & b ) { T tmp = b ; b = a ; a = tmp ;                } ////////////////////
    template <typename T> inline long myint  ( T   x         ) { return (long) x ;                            } ////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some simple and essential mathematics functions: ////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T GCD (T a, T b) { ////////////////////////////////////////////////////////////////////////////////
        T ret ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        while( (a!=0) && (b!=0) ) { ////////////////////////////////////////////////////////////////////////////////////////////////
            if (a>b) { a = a % b ; ret = b ; } /////////////////////////////////////////////////////////////////////////////////////
            else     { b = b % a ; ret = a ; } /////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        return ret; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> inline T LCM (T a, T b) { ////////////////////////////////////////////////////////////////////////////////
        T ret ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ret = GCD(a,b); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (ret>0) { ret = a * ( b / ret ) ; } /////////////////////////////////////////////////////////////////////////////////////
        return ret; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some useful OS related functions : //////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void starter_self ( std::vector <std::string> & program ) { ////////////////////////////////////////////////////////////////////
        std::vector <char*> arrs ; /////////////////////////////////////////////////////////////////////////////////////////////////
        int j = program.size() ; ///////////////////////////////////////////////////////////////////////////////////////////////////
        arrs.resize(j+1); //////////////////////////////////////////////////////////////////////////////////////////////////////////
        for(int i=0;i<j;i++) { arrs[i] = & (program[i][0]) ; } /////////////////////////////////////////////////////////////////////
        arrs[j] = (char*) NULL ; ///////////////////////////////////////////////////////////////////////////////////////////////////
        execvp ( (const char *) arrs[0] , & (arrs[0]) ) ; //////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    pid_t starter_fork ( std::vector <std::string> & program ) { ///////////////////////////////////////////////////////////////////
        pid_t tmp_pid = fork(); ////////////////////////////////////////////////////////////////////////////////////////////////////
        if (tmp_pid==0) { starter_self (program) ; } ///////////////////////////////////////////////////////////////////////////////
        else { return tmp_pid ; } //////////////////////////////////////////////////////////////////////////////////////////////////
        return tmp_pid ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void waitonall (std::vector <pid_t> childs) { //////////////////////////////////////////////////////////////////////////////////
        for(int i=0;i<childs.size();i++) { pid_t tmp = waitpid ( (pid_t) childs[i] , (int *) NULL , (int) 0 ) ; } //////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class GetArgs { ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> args ; ///////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        GetArgs  (int _argc, char ** _argv) {for(size_t i=0;i<_argc;i++){args.push_back(_argv[i]);}} ///////////////////////////////
        ~GetArgs ()                         {} /////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) { return args[i]      ; } //////////////////////////////////////////////////////
        inline size_t        operator () ()         { return args.size () ; } //////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Nice Class to handel forking: ///////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class ForkMe { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        private: ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            std::vector <pid_t> kids  ; ////////////////////////////////////////////////////////////////////////////////////////////
            bool                child ; ////////////////////////////////////////////////////////////////////////////////////////////
            size_t              kid_count ; ////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        public: ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline bool WaitOnKids () { ////////////////////////////////////////////////////////////////////////////////////////////
                if      ( child           ) { exit (0)         ; return false ;               } ////////////////////////////////////
                else if ( kids.size() > 0 ) { waitonall (kids) ; kids.clear() ; return true ; } ////////////////////////////////////
                else                        { return false     ;                              } ////////////////////////////////////
                kid_count = 1 ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ForkMe  () { kids.clear () ; child = false ; kid_count = 1 ; } /////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ~ForkMe () { if (child) { exit (0) ; } else { WaitOnKids () ; } } //////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline bool InKid () { /////////////////////////////////////////////////////////////////////////////////////////////////
                if (!child){ ///////////////////////////////////////////////////////////////////////////////////////////////////////
                    pid_t tmp_pid = fork () ; //////////////////////////////////////////////////////////////////////////////////////
                    if (tmp_pid==0) { child = true             ; return true  ; } //////////////////////////////////////////////////
                    else            { kids.push_back (tmp_pid) ; kid_count++ ; return false ; } ////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { exit (0) ; return false ; } /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            inline void operator () (size_t _count=1) { ////////////////////////////////////////////////////////////////////////////
                if(kid_count>_count) { WaitOnKids () ; } ///////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class starter { ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The main elements: //////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ForkMe forks ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Constructor and Destructor: /////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        starter  () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~starter () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The main functions: /////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void series (std::vector <std::string> & program) { ////////////////////////////////////////////////////////////////////////
            ForkMe tmp ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            if(tmp.InKid()) {starter_self(program);} ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void parallel (std::vector <std::string> & program) { //////////////////////////////////////////////////////////////////////
            if(forks.InKid()) {starter_self(program);} /////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void wait () {forks.WaitOnKids();} /////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Some functions to simplify handling vectors: ////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void clone_vector ( const std::vector <T> & src , std::vector <T> & dest ) { /////////////////////////////
        size_t n = src.size() ; ////////////////////////////////////////////////////////////////////////////////////////////////////
        dest.resize(n); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        (void *) memcpy ( (void *) &(dest[0]), (const void *) &(src[0]), (size_t) n*sizeof(T) ); ///////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void deduplicate (std::vector <T> & array) { /////////////////////////////////////////////////////////////
        std::vector <T> tmp_array ; ////////////////////////////////////////////////////////////////////////////////////////////////
        size_t SZ = array.size(); //////////////////////////////////////////////////////////////////////////////////////////////////
        if(SZ>1) { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            std::sort(array.begin(),array.end()); tmp_array.push_back(array[0]); ///////////////////////////////////////////////////
            for(size_t i=1;i<SZ;i++) if(array[i]!=array[i-1]) {tmp_array.push_back(array[i]);} /////////////////////////////////////
            array.resize(tmp_array.size()) ; ///////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void *) &(array[0]) , (const void *) &(tmp_array[0]) , sizeof(T) * tmp_array.size() ) ; //////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Function to read a file line by line: ///////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    void getnames ( std::vector <std::string> & lines , std::string filename ) { ///////////////////////////////////////////////////
        lines.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char *line=NULL; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t len=0; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ssize_t read; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FILE *stream = fopen (&(filename[0]),"r") ; ////////////////////////////////////////////////////////////////////////////////
        while ((read = getline(&line, &len, stream)) != -1) { //////////////////////////////////////////////////////////////////////
            std::string linename(line); ////////////////////////////////////////////////////////////////////////////////////////////
            linename[linename.size()-1]=0; /////////////////////////////////////////////////////////////////////////////////////////
            lines.push_back(linename); /////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (len>0) {free(line);} ///////////////////////////////////////////////////////////////////////////////////////////////////
        fclose(stream); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileLines { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> lines    ; ///////////////////////////////////////////////////////////////////////////////////////
        std::string               filename ; ///////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileLines  (std::string _filename) : filename(_filename) {getnames(lines,filename);} ///////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~FileLines () {} ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) { return lines[i]      ; } /////////////////////////////////////////////////////
        inline size_t        size        ()         { return lines.size () ; } /////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) { return lines[i]      ; } /////////////////////////////////////////////////////
        inline size_t        operator () ()         { return lines.size () ; } /////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (FILE *f) { for (size_t i=0;i<lines.size();i++) {fprintf(f,"%s\n",&(lines[i][0]));} } //////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<lines.size();i++) {printf("%ld => [%s]\n",i,&(lines[i][0]));} } /////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class StringSplit { ////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The Main Data Elements: /////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::string               line    ; ////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> words   ; ////////////////////////////////////////////////////////////////////////////////////////
        char                      delimit ; ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Important functions: ////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        StringSplit  ( std::string _line = "" , char _delimit = ' ' ) : line(_line) , delimit(_delimit) { //////////////////////////
            std::vector <char> buf ; buf.reserve(line.size()) ; ////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<line.size();i++) { ///////////////////////////////////////////////////////////////////////////////////
                if (line[i]==delimit) { ////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back(line[i]); ////////////////////////////////////////////////////////////////////////////////////////
                    buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////
                    words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////
                    buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else { buf.push_back(line[i]); } ///////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (buf.size()>0) { ////////////////////////////////////////////////////////////////////////////////////////////////////
                buf.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
                words.push_back(std::string(&(buf[0]))); ///////////////////////////////////////////////////////////////////////////
                buf.resize(0) ; ////////////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~StringSplit () {} /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Some convinent functions: ///////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline std::string & operator [] (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        size        ()         {return words.size() ; } ///////////////////////////////////////////////////////
        inline std::string & operator () (size_t i) {return words[i]     ; } ///////////////////////////////////////////////////////
        inline size_t        operator () ()         {return words.size() ; } ///////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Print the string: ///////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void show (std::string & in_line) { ////////////////////////////////////////////////////////////////////////////////////////
            std::vector <char> outline ; ///////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<words.size();i++) for(size_t j=0;j<words[i].size();j++) if(words[i][j]!=(char)0) {outline.push_back(words[i][j]);}
            outline.push_back((char)0); ////////////////////////////////////////////////////////////////////////////////////////////
            in_line = std::string( &(outline[0]) ); ////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () (std::string & in_line) {show(in_line);} ///////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void debug_show () { for (size_t i=0;i<words.size();i++) {printf("(%ld:%s)",i,&(words[i][0]));} } //////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // The Main and most important class for simplifying file handeling: ///////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class FileFD { /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        std::string  filename  ;
        int          fd        ;
        struct stat  abtme     ;
        int          filemode  ;
        void        *mapped    ;
        size_t       maplength ;
        int          mmapprot  ;

    public:
        void construct ( std::string Afile = std::string("outfile") ) {
            filename  = Afile      ;
            fd        = -1         ;
            filemode  = -1         ;
            mapped    = MAP_FAILED ;
            mmapprot  = PROT_NONE  ;
            maplength = 0          ;
        }
        int closefile () {
            unmapfile()          ;
            filemode = -1        ;
            mmapprot = PROT_NONE ;
            if (fd<0) {return 0;}
            else {
                int ret = (int) close ( (int) fd ) ;
                fd = -1 ;
                return ret ;
            }
        }
        inline void check_file_mode (int newfilemode = -1) {
            if (filemode!=newfilemode) {closefile();}
            if (fd<0) {
                fd = (int) open ( (const char *) &(filename[0]) , newfilemode , (mode_t) 0755 ) ;
                filemode = newfilemode ;
            }
        }
        inline void readfile   () { check_file_mode ( (int) O_RDONLY                     ) ; mmapprot = ( (int) PROT_READ               ) ; }
        inline void writefile  () { check_file_mode ( (int) O_WRONLY | O_CREAT | O_TRUNC ) ; mmapprot = ( (int) PROT_WRITE              ) ; }
        inline void appendfile () { check_file_mode ( (int) O_RDWR   | O_CREAT           ) ; mmapprot = ( (int) PROT_READ  | PROT_WRITE ) ; }
        inline void destroy    () { closefile       (                                    ) ;                                                }

        FileFD  ( const char *Afile ) { construct ( Afile ) ; }
        FileFD  (                   ) { construct (       ) ; }
        FileFD  ( std::string Afile ) { construct ( Afile ) ; }
        ~FileFD (                   ) { destroy   (       ) ; }

        void reconstruct (std::string Afile = std::string("outfile")) { destroy() ; construct (Afile) ; }
        void reconstruct (char *Afile) { reconstruct (std::string(Afile)) ; }
        inline FileFD & operator () ( std::string name ) { reconstruct(name) ; return (*this); }

        inline int truncatefile ( off_t length = 0 ) { return (int) ftruncate ( (int) fd , (off_t) length ) ; }
        inline off_t seekfile ( off_t offset = 0 , int whence = SEEK_CUR ) { return (off_t) lseek ( (int) fd , (off_t) offset , (int) whence ) ; }
        inline ssize_t read2file ( void *buf = NULL , size_t count = 0 ) { return (ssize_t) read ( (int) fd , ( void *) buf , (size_t) count ) ; }
        inline ssize_t write2file ( const void *buf = NULL , size_t count = 0 ) { return (ssize_t) write ( (int) fd , (const void *) buf , (size_t) count ) ; }
        inline int info () { return (int) fstat ( (int) fd , (struct stat *) &abtme ) ; }
        inline off_t sizefile () { info() ; return (off_t) abtme.st_size ; }
        inline std::string getfilename () { return filename; }
        inline off_t operator () ( off_t offset = 0 ) { return seekfile ( offset ) ; }
        inline FileFD & operator [] ( off_t pos ) { seekfile ( (off_t) pos , SEEK_SET ) ; return (*this) ; }
        inline int getfd () { return fd ; }

        void * mapfile ( size_t length, off_t offset = 0 ) {
            if( (maplength==0) && (mmapprot!=PROT_NONE) && (mapped==MAP_FAILED) ) {
                off_t total_len = length + offset ;
                if (sizefile()<total_len) {truncatefile(total_len);}
                mapped = (void *) mmap ( (void *) NULL , (size_t) length, (int) mmapprot , (int) MAP_SHARED , (int) fd , (off_t) offset );
                if (mapped!=MAP_FAILED) {maplength=length;}
                else {printf("MMAP FAILED 1 !!! %s\n",&(filename[0]));}
            }
            else {printf("MMAP FAILED 2 !!!\n");}
            return mapped;
        }

        int unmapfile () {
            int ret = 0 ;
            if ( (mapped!=MAP_FAILED) && (maplength>0) && (mmapprot!=PROT_NONE) ) {
                ret = (int) munmap ( (void *) mapped , (size_t) maplength ) ;
                maplength = 0 ;
                mapped = MAP_FAILED ;
            }
            return ret;
        }

        inline size_t getmaplength () { return maplength ; }

        template <typename T> inline ssize_t multiread2file  ( T &buf , size_t count = 1 ) { return read2file  ( (      void *) &buf , (size_t) sizeof(T) * count ) ; }
        template <typename T> inline ssize_t multiwrite2file ( T &buf , size_t count = 1 ) { return write2file ( (const void *) &buf , (size_t) sizeof(T) * count ) ; }

        template <typename T> inline ssize_t WriteVector ( std::vector <T> &out ) {
            size_t count = out.size() ;
            ssize_t writtensize = multiwrite2file (count) ;
            writtensize = writtensize + multiwrite2file (out[0],count) ;
            return writtensize;
        }

        template <typename T> inline ssize_t ReadVector ( std::vector <T> &out ) {
            size_t count = 0 ;
            size_t oldsize = out.size() ;
            ssize_t writtensize = multiread2file (count) ;
            out.resize ( oldsize + count ) ;
            writtensize = multiread2file ( out[oldsize], count ) ;
            return writtensize;
        }

        inline ssize_t WriteString ( std::string &out ) {
            size_t count       = out.size() ;
            ssize_t writtensize = multiwrite2file ( count ) ;
            writtensize = writtensize + multiwrite2file(out[0],count) ;
            return writtensize;
        }

        inline ssize_t operator >> ( char      & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( char        out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( int       & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( int         out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( float     & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( float       out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( double    & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( double      out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( long      & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( long        out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator >> ( size_t    & out ) { return multiread2file  ( out ) ; }
        inline ssize_t operator << ( size_t      out ) { return multiwrite2file ( out ) ; }
        inline ssize_t operator << ( std::string out ) { return WriteString     ( out ) ; }

        template <typename T> inline ssize_t operator << ( std::vector <T> &out ) { return WriteVector(out); }
        template <typename T> inline ssize_t operator >> ( std::vector <T> &out ) { return ReadVector (out); }
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Simple function for TRUE random number generation: //////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    double unique () { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        struct timespec timeout ; //////////////////////////////////////////////////////////////////////////////////////////////////
        clock_gettime(CLOCK_REALTIME,&timeout); ////////////////////////////////////////////////////////////////////////////////////
        double ret = (double) ( timeout.tv_sec + ( (double) timeout.tv_nsec / 1000000000 ) ) ; /////////////////////////////////////
        FileFD urandom((char *)"/dev/urandom"); ////////////////////////////////////////////////////////////////////////////////////
        urandom.readfile(); ////////////////////////////////////////////////////////////////////////////////////////////////////////
        double rnd ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
        urandom >> rnd ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ret = ret * rnd ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
        return ret;  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> void GetUnique (T & Var) { double ptr = unique() ; Var=*((T*)&ptr); } ////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class for simplifying memory mapping and array handeling: ///////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FileArray { ////////////////////////////////////////////////////////////////////////////////////////

    private:
        T *mainptr  ;
        size_t sizes[4] ;
        std::string filename ;
        FileFD filefd ;
        size_t offset ;
        size_t begin, end, length ;
        size_t act_begin, act_end, act_length ;

    public:
        inline void construct ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) {
            filename = Afilename ;
            filefd(filename).readfile() ;
            sizes[0] = 4096 ;
            sizes[1] = sizeof (T) ;
            sizes[2] = LCM (sizes[0],sizes[1]) ;
            sizes[3] = sizes[2] / sizes[1] ;
            offset = Aoffset ;
            begin = 0 ; act_begin = 0 ;
            end = 0 ; act_end = 0 ;
            length = 0 ; act_length = 0 ;
        }

        inline void destroy () { filefd.destroy () ; }
        inline void reconstruct ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) { destroy(); construct(Afilename,Aoffset); }
        inline FileArray & operator () ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) {
            reconstruct (Afilename,Aoffset) ;
            return (*this) ;
        }

        FileArray ( std::string Afilename = std::string ("outfile") , size_t Aoffset = 0 ) { construct(Afilename,Aoffset); }
        ~FileArray () {destroy();}

        inline void writeable ( bool arg = true ) {
            if(arg) {filefd(filename).appendfile();}
            else {filefd(filename).readfile();}
        }

        void map (size_t t_begin=0, size_t t_length=1) {
            size_t t_end = t_begin + t_length ;
            if ((t_begin<begin)||(t_end>end)) {
                /* Match to sector sizes: */ {
                    begin = myint ((double)t_begin/sizes[3]) ; begin = begin * sizes[3] ;
                    length = myint ((double)t_length/sizes[3]) ; length++ ; length = length * sizes[3] ;
                    end = begin + length ;
                }
                /* Reinitiate map: */ {
                    filefd.unmapfile () ;
                    mainptr = (T*) filefd.mapfile ( (length*sizes[1]) , (begin*sizes[1]) + (offset*sizes[0]) ) ;
                }
            }
        }

        inline T & operator () ( size_t A_begin=0 , size_t A_length=1 ) {
            map (A_begin,A_length) ;
            return mainptr [A_begin-begin] ;
        }

        inline off_t filesize () { return filefd.sizefile () ; }
        inline off_t size () { return filefd.sizefile () / sizes[1] ; }
        inline off_t size ( long num ) { filefd.unmapfile(); filefd.truncatefile(num*sizes[1]); return size(); }
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class FileVector { ///////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileArray <T> infile ; /////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t count ; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FileVector(std::string name): infile(name){ ////////////////////////////////////////////////////////////////////////////////
            infile.writeable(); ////////////////////////////////////////////////////////////////////////////////////////////////////
            count=0; ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            infile.size(count); ////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~FileVector(){infile.size(count);} /////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t size() {return count ;} ////////////////////////////////////////////////////////////////////////////////
        inline void resize(size_t _size) {count=_size;} //////////////////////////////////////////////////////////////////////
        inline void push_back (T indata) { /////////////////////////////////////////////////////////////////////////////////////////
            infile(count) = indata ; ///////////////////////////////////////////////////////////////////////////////////////////////
            count++ ; //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return infile(i);} //////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////
    template < typename T > class latexshow { /////////////////////////
        ///////////////////////////////////////////////////////////////
    private:
        ///////////////////////////////////////////////////////////////
        long power; ///////////////////////////////////////////////////
        T num; ////////////////////////////////////////////////////////
        T input; //////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline void reduce () { ///////////////////////////////////////
            ///////////////////////////////////////////////////////////
            while ((-1<num) && (num<1) && (num!=0)) { /////////////////
                num = num * 10.0; /////////////////////////////////////
                power--; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
            while ((num > 10) || (-10 > num)) { ///////////////////////
                num = num / 10.0; /////////////////////////////////////
                power++; //////////////////////////////////////////////
            } /////////////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * show (char * b) { ///////////////////////////////
            ///////////////////////////////////////////////////////////
            if ( mymod(power) > limit ) { /////////////////////////////
                sprintf (b, "{$%.3lf \\times 10^{%ld}$}", num, power);
            } else { //////////////////////////////////////////////////
                sprintf (b, "{$%.3lf$}", input); //////////////////////
            } /////////////////////////////////////////////////////////
            return b ; ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
    public:
        ///////////////////////////////////////////////////////////////
        size_t limit; /////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        latexshow (T a) { /////////////////////////////////////////////
            ///////////////////////////////////////////////////////////
            input = a; ////////////////////////////////////////////////
            num = a; //////////////////////////////////////////////////
            power = 0; ////////////////////////////////////////////////
            limit = 2; ////////////////////////////////////////////////
            reduce (); ////////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        ~latexshow () { ///////////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////
        inline char * operator  () (char * b) { ///////////////////////
            return show (b); //////////////////////////////////////////
        } /////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////

    }; ////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Class to Easily generate fancy looking tables: //////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class flowtable { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        size_t current ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T>           L     ; //////////////////////////////////////////////////////////////////////////////////////////
        std::vector <std::string> names ; //////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void safefill ( size_t CLimit ) { //////////////////////////////////////////////////////////////////////////////////////////
            while ( L.size     () <= CLimit    ) { L.push_back     (0)                      ; } /////////////////////////////////////
            while ( names.size () <  L.size () ) { names.push_back (std::string("nothing")) ; } /////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void safefill ()    { safefill (current) ; } ////////////////////////////////////////////////////////////////////////
        inline void namefill ()    { if (L.size()>0) { safefill (L.size()-1) ; } } /////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void copyfrom ( const flowtable <T> & other ) { /////////////////////////////////////////////////////////////////////
            safefill (other.L.size()) ; ////////////////////////////////////////////////////////////////////////////////////////////
            memcpy ( (void*) &(L[0]) , (const void*) &(other.L[0]) , (size_t) sizeof(T) * L.size() ) ; /////////////////////////////
            current = other.current ; //////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void startover () { current = 0 ; } /////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( T val = 1 , std::string name = "noothing" ) { ///////////////////////////////////////////////////////////
            safefill () ; //////////////////////////////////////////////////////////////////////////////////////////////////////////
            L[current]     = L[current] + val ; ////////////////////////////////////////////////////////////////////////////////////
            names[current] = name             ; ////////////////////////////////////////////////////////////////////////////////////
            current++                         ; ////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void fill ( bool val , std::string name = "nothing" ) { /////////////////////////////////////////////////////////////
            if (val) {fill(1,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
            else     {fill(0,name);} ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        char * showhorizontal (std::string & linetitle) { //////////////////////////////////////////////////////////////////////////
            std::vector <std::string> parts ; /**/ { ///////////////////////////////////////////////////////////////////////////////
                std::string tmp = "\\hline " + linetitle + " &" ; //////////////////////////////////////////////////////////////////
                parts.push_back (tmp) ; ////////////////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++){ ////////////////////////////////////////////////////////////////////////////////////////
                latexshow <T> tmplatex (L[i]) ; ////////////////////////////////////////////////////////////////////////////////////
                char tmpbuf [512] ; ////////////////////////////////////////////////////////////////////////////////////////////////
                tmplatex (tmpbuf) ; ////////////////////////////////////////////////////////////////////////////////////////////////
                if (i<L.size()-1) {parts.push_back(std::string(tmpbuf)+" &");} /////////////////////////////////////////////////////
                else {parts.push_back(std::string(tmpbuf)+" \\\\");} ///////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            linetitle = parts[0] ; /////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=1;i<parts.size();i++){ ////////////////////////////////////////////////////////////////////////////////////
                linetitle = linetitle + parts[i] ; /////////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            return &(linetitle[0]) ; ///////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void showvals (std::vector <std::string> & outvals) { //////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<L.size();i++) { ///////////////////////////////////////////////////////////////////////////////////////
                latexshow <double> tmpshow (L[i]) ; ////////////////////////////////////////////////////////////////////////////////
                char tmp[128] ; tmpshow(tmp) ; /////////////////////////////////////////////////////////////////////////////////////
                outvals.push_back(std::string(tmp)); ///////////////////////////////////////////////////////////////////////////////
            } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () () {startover();} //////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( T    val , std::string name = "nothing" , bool inflag = true ) { /////////////////////////////////
            if   (inflag) { fill ( val  , name ) ; } ///////////////////////////////////////////////////////////////////////////////
            else          { fill ( (T)0 , name ) ; } ///////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void operator () ( bool val , std::string name = "nothing" ) {fill(val,name);} //////////////////////////////////////
        inline char * operator () (std::string & linetitle) {return showhorizontal(linetitle);} ////////////////////////////////////
        inline size_t size() {return L.size();} ////////////////////////////////////////////////////////////////////////////////////
        inline T & operator [] (size_t i) {return L[i];} ///////////////////////////////////////////////////////////////////////////
        inline std::vector <std::string> & operator () (std::vector <std::string> & outvals) { /////////////////////////////////////
            showvals(outvals); /////////////////////////////////////////////////////////////////////////////////////////////////////
            return outvals; ////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline size_t operator >> (CPPFileIO::FileFD & outfile) {outfile<<L;} //////////////////////////////////////////////////////
        inline size_t operator << (CPPFileIO::FileFD & outfile) {outfile>>L;} //////////////////////////////////////////////////////
        inline void operator = (const flowtable <T> & other) {copyfrom(other);} ////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void filewrite (std::string filename) { ////////////////////////////////////////////////////////////////////////////////////
            FILE *f = fopen (&(filename[0]),"w") ; /////////////////////////////////////////////////////////////////////////////////
            namefill(); ////////////////////////////////////////////////////////////////////////////////////////////////////////////
            size_t min_v = L.size(); ///////////////////////////////////////////////////////////////////////////////////////////////
            for (size_t i=0;i<min_v;i++) {fprintf(f," L [%ld] = %e \t : \t %s \n",i,(double)L[i],&(names[i][0]));} /////////////////
            fclose(f); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable() { //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            L.clear(); /////////////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        flowtable (const flowtable & other) { //////////////////////////////////////////////////////////////////////////////////////
            copyfrom(other); ///////////////////////////////////////////////////////////////////////////////////////////////////////
            current=0; /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~flowtable(){} /////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Printing the Tables: ////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class flowtables { /////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        FILE *f ;
    public:
        void operator () (std::string infile) {
            FileLines reader(infile);
            fprintf(f,"{|");
            for (size_t i=0;i<reader.size();i++) {fprintf(f,"c|");}
            fprintf(f,"}\n");
            for (size_t i=0;i<reader();i++) {
                if(i==0) {fprintf(f,"\\hline ");}
                else {fprintf(f,"& ");}
                fprintf(f,"%s",&(reader(i)[0]));
            }
            fprintf(f," \\\\ \n");
        }
        template <typename T> void operator () (flowtable <T> & intable, std::string eventtype) {
            fprintf(f,"%s\n",intable(eventtype));
        }
        flowtables  (FILE * _f) {f=_f;fprintf(f,"\\begin{tabular}");}
        ~flowtables ()          {fprintf(f,"\\hline \\end{tabular}\n");} ///////////////////////////////////////////////////////////
    }; /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class LatexPrintMatrix {
    private:
        std::vector <std::string> elements ;
        size_t X, Y ;
        inline std::string & GetElement ( size_t x , size_t y ) {
            if(x>=X) {printf("BUG!!! out of bounds in x !!!\n");}
            if(y>=Y) {printf("BUG!!! out of bounds in y !!!\n");}
            return elements [x+(X*y)] ;
        }
        void Write2FILE ( FILE * f ) {
            fprintf(f,"\\begin{tabular}");
            for(size_t x=0;x<X;x++) {
                if(x==0){fprintf(f,"{|");}
                fprintf(f,"c|");
                if(x==(X-1)){fprintf(f,"}\n");}
            }
            for (size_t y=0;y<Y;y++) {
                for (size_t x=0;x<X;x++) {
                    if(x==0) {fprintf(f," \\hline %s ",&(GetElement(x,y)[0]));}
                    else     {fprintf(f," & %s ",&(GetElement(x,y)[0]));}
                }
                fprintf(f," \\\\ \n");
            }
            fprintf(f,"\\hline \\end{tabular}\n");
        }
        inline void Write2FILE ( std::string filename ) {
            FILE *f = fopen(&(filename[0]),"w");
            Write2FILE(f);
            fclose(f);
        }
    public:
        inline void operator () (std::vector <std::string> & x, size_t y) {
            size_t limit = mymin (x.size(),X) ;
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x[i];}
        }
        inline void operator () (size_t x, std::vector <std::string> & y) {
            size_t limit = mymin (y.size(),Y) ;
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y[i];}
        }
        inline void operator () (FileLines & x, size_t y) {
            size_t limit = mymin(x(),X);
            for(size_t i=0;i<limit;i++) {GetElement(i,y)=x(i);}
        }
        inline void operator () (size_t x, FileLines & y) {
            size_t limit = mymin(y(),Y);
            for(size_t i=0;i<limit;i++) {GetElement(x,i)=y(i);}
        }
        inline void operator () (FILE *f)              {Write2FILE(f);}
        inline void operator () (std::string filename) {Write2FILE(filename);}
        LatexPrintMatrix (size_t _X, size_t _Y) {
            X=_X;Y=_Y;
            elements.resize(X*Y);
        }
        ~LatexPrintMatrix(){}
    };


    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Convinent multi threadable class for uniform double random number generation: ///////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T> class myrandgen { ////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        std::vector <T*> engines ; /////////////////////////////////////////////////////////////////////////////////////////////////
        std::uniform_real_distribution <double> dist ; /////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline void allocate () { //////////////////////////////////////////////////////////////////////////////////////////////////
            std::random_device random_seeds ; //////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {engines[i]=new T(random_seeds());} ///////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        double low, high ; /////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        myrandgen(size_t threads, double _low=0, double _high=1) : low(_low) , high(_high) , dist(_low,_high) { ////////////////////
            engines.resize(threads) ; //////////////////////////////////////////////////////////////////////////////////////////////
            allocate() ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ~myrandgen(){ //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            for(size_t i=0;i<engines.size();i++) {delete engines[i];} //////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        inline double operator [] (size_t th) { ////////////////////////////////////////////////////////////////////////////////////
            double ret = dist(engines[th][0]) ; ////////////////////////////////////////////////////////////////////////////////////
            return ret ; ///////////////////////////////////////////////////////////////////////////////////////////////////////////
        } //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    } ; ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    class ToDir {
    private:
        std::string originaldir ;
        inline void godir (std::string dirname) {
            mkdir((const char*)&(dirname[0]),(mode_t)0755);
            chdir((const char*)&(dirname[0]));
        }
        bool goback ;
    public:
        inline void operator () (std::string dirname) {godir(dirname);}
        inline void operator () (const char *dirname) {godir(std::string(dirname));}
        inline void operator () (long innum) {
            char tmp[128] ;
            sprintf(tmp,"%ld",innum);
            godir(std::string(tmp));
        }
        inline void operator () () {godir(originaldir);}
        inline void showdir() {
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            printf("%s\n",tmp);
        }
        inline std::string getoriginal () {return originaldir;}
        ToDir(bool _goback=false){
            goback = _goback ;
            char tmp[1024] ;
            getcwd((char*)tmp,(size_t)1024);
            originaldir = std::string(tmp);
            std::cout << originaldir << "\n" ;
        }
        ~ToDir(){if(goback){godir(originaldir);}}
    };


} //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif
